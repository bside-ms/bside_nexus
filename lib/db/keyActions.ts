import { and, asc, eq, inArray, isNull } from 'drizzle-orm';
import { db } from '@/db';
import type { KeyAssignmentEntry, KeyItemEntry, KeysBaseEntry } from '@/db/schema';
import { keyAssignmentTable, keyItemsTable, keyProtocolsTable, keysBaseTable, userProfilesTable } from '@/db/schema';

// Key Types (Schließungen)
export interface CreateKeyTypeInput {
    id: string; // uuid generated by caller
    keyNr: number;
    keyDescription: string;
    createdBy?: string | null;
}

export const createKeyType = async (input: CreateKeyTypeInput): Promise<KeysBaseEntry | undefined> => {
    const [row] = await db
        .insert(keysBaseTable)
        .values({
            id: input.id,
            keyNr: input.keyNr,
            keyDescription: input.keyDescription,
            createdBy: input.createdBy ?? null,
        })
        .returning();
    return row;
};

export const updateKeyType = async (
    id: string,
    patch: Partial<Pick<CreateKeyTypeInput, 'keyNr' | 'keyDescription'>>,
): Promise<KeysBaseEntry | undefined> => {
    const [row] = await db.update(keysBaseTable).set(patch).where(eq(keysBaseTable.id, id)).returning();
    return row;
};

export const softDeleteKeyType = async (id: string): Promise<KeysBaseEntry | undefined> => {
    const [row] = await db.update(keysBaseTable).set({ deleteAt: new Date() }).where(eq(keysBaseTable.id, id)).returning();
    return row;
};

export const listKeyTypes = async (): Promise<Array<KeysBaseEntry>> => {
    return db.select().from(keysBaseTable).where(isNull(keysBaseTable.deleteAt)).orderBy(asc(keysBaseTable.keyNr));
};

// Key Items
export interface CreateKeyItemInput {
    id: string; // uuid
    keyTypeId: string;
    seqNumber: number;
    comment?: string | null;
}

export const createKeyItem = async (input: CreateKeyItemInput): Promise<KeyItemEntry | undefined> => {
    const [row] = await db
        .insert(keyItemsTable)
        .values({
            id: input.id,
            keyTypeId: input.keyTypeId,
            seqNumber: input.seqNumber,
            status: 'active',
            comment: input.comment ?? null,
        })
        .returning();
    return row;
};

export const changeKeyItemStatus = async (
    keyItemId: string,
    status: 'active' | 'inactive' | 'lost' | 'broken' | 'destroyed',
): Promise<KeyItemEntry | undefined> => {
    // prevent deactivate/destroy while actively assigned (except marking lost which closes via separate flow)
    if (status !== 'active') {
        const active = await db
            .select({ id: keyAssignmentTable.id })
            .from(keyAssignmentTable)
            .where(
                and(eq(keyAssignmentTable.keyItemId, keyItemId), isNull(keyAssignmentTable.returnedAt), isNull(keyAssignmentTable.lostAt)),
            )
            .limit(1);
        if (active.length > 0 && status !== 'lost') {
            throw new Error('Statusänderung nicht möglich: Schlüssel ist aktuell ausgegeben.');
        }
    }
    const [row] = await db.update(keyItemsTable).set({ status }).where(eq(keyItemsTable.id, keyItemId)).returning();
    return row;
};

// Fill up missing key items until target quantity (seqNumbers are 1..N)
export const fillUpKeyItems = async (keyTypeId: string, targetQuantity: number): Promise<Array<number>> => {
    return db.transaction(async (tx) => {
        const existing = await tx
            .select({ seqNumber: keyItemsTable.seqNumber })
            .from(keyItemsTable)
            .where(eq(keyItemsTable.keyTypeId, keyTypeId))
            .orderBy(keyItemsTable.seqNumber);
        const have = new Set(existing.map((e) => e.seqNumber));
        const toCreate: Array<number> = [];
        for (let i = 1; i <= targetQuantity; i++) {
            if (!have.has(i)) {
                toCreate.push(i);
            }
        }
        if (toCreate.length === 0) {
            return [] as Array<number>;
        }

        return toCreate;
    });
};

// Ausgabe (Issuance)
export const issueKeys = async (userProfileId: string, keyItemIds: Array<string>, createdBy?: string | null): Promise<Array<string>> => {
    if (keyItemIds.length === 0) {
        return [] as Array<string>;
    } // no protocols
    // Validate profile exists and not deleted
    const profile = await db
        .select({ id: userProfilesTable.id, deleted: userProfilesTable.deleteAt })
        .from(userProfilesTable)
        .where(eq(userProfilesTable.id, userProfileId))
        .limit(1);
    if (!profile[0] || profile[0].deleted) {
        throw new Error('UserProfile nicht gefunden oder gelöscht.');
    }

    // Load key items and check availability
    const items = await db.select().from(keyItemsTable).where(inArray(keyItemsTable.id, keyItemIds));
    if (items.length !== keyItemIds.length) {
        throw new Error('Einige Schlüssel wurden nicht gefunden.');
    }
    const notActive = items.find((i) => i.status !== 'active');
    if (notActive) {
        throw new Error('Ein Schlüssel ist nicht aktiv und kann nicht ausgegeben werden.');
    }

    // ensure no active assignment
    const actives = await db
        .select({ id: keyAssignmentTable.id, keyItemId: keyAssignmentTable.keyItemId })
        .from(keyAssignmentTable)
        .where(
            and(
                inArray(keyAssignmentTable.keyItemId, keyItemIds),
                isNull(keyAssignmentTable.returnedAt),
                isNull(keyAssignmentTable.lostAt),
            ),
        );
    if (actives.length > 0) {
        throw new Error('Mindestens ein Schlüssel ist bereits aktiv zugewiesen.');
    }

    // Batch into protocols of 4
    const protocolIds: Array<string> = [];
    await db.transaction(async (tx) => {
        for (let i = 0; i < keyItemIds.length; i += 4) {
            const batch = keyItemIds.slice(i, i + 4);
            const protocolId = crypto.randomUUID();
            await tx
                .insert(keyProtocolsTable)
                .values({ id: protocolId, protocolType: 'issuance', userProfileId, createdBy: createdBy ?? null })
                .returning();
            protocolIds.push(protocolId);
            for (const keyItemId of batch) {
                await tx.insert(keyAssignmentTable).values({
                    id: crypto.randomUUID(),
                    keyItemId,
                    userProfileId,
                    issuanceProtocolId: protocolId,
                    createdBy: createdBy ?? null,
                });
            }
        }
    });
    return protocolIds;
};

// Rückgabe (Return) - close selected assignments; create 4-per-protocol return docs
export const returnKeys = async (assignmentIds: Array<string>, createdBy?: string | null): Promise<Array<string>> => {
    if (assignmentIds.length === 0) {
        return [] as Array<string>;
    }
    // Load assignments and ensure open (not returned, not lost)
    const assignments = await db.select().from(keyAssignmentTable).where(inArray(keyAssignmentTable.id, assignmentIds));
    if (assignments.length !== assignmentIds.length) {
        throw new Error('Einige Zuweisungen wurden nicht gefunden.');
    }
    const invalid = assignments.find((a) => a.returnedAt !== null || a.lostAt !== null);
    if (invalid) {
        throw new Error('Mindestens eine Zuweisung ist bereits geschlossen/verloren.');
    }

    const protocolIds: Array<string> = [];
    await db.transaction(async (tx) => {
        for (let i = 0; i < assignmentIds.length; i += 4) {
            const batch = assignmentIds.slice(i, i + 4);
            const protocolId = crypto.randomUUID();
            await tx
                .insert(keyProtocolsTable)
                .values({
                    id: protocolId,
                    protocolType: 'return',
                    userProfileId: assignments[0]!.userProfileId,
                    createdBy: createdBy ?? null,
                })
                .returning();
            protocolIds.push(protocolId);
            const now = new Date();
            await tx
                .update(keyAssignmentTable)
                .set({ returnedAt: now, returnProtocolId: protocolId })
                .where(inArray(keyAssignmentTable.id, batch));
        }
    });
    return protocolIds;
};

// Verlust markieren
export const markLost = async (assignmentId: string): Promise<KeyAssignmentEntry | undefined> => {
    return db.transaction(async (tx) => {
        const aList = await tx.select().from(keyAssignmentTable).where(eq(keyAssignmentTable.id, assignmentId)).limit(1);
        const a = aList[0];
        if (!a) {
            throw new Error('Zuweisung nicht gefunden.');
        }
        if (a.returnedAt) {
            throw new Error('Zuweisung bereits zurückgegeben.');
        }
        if (a.lostAt) {
            return a;
        } // already lost
        const now = new Date();
        const [updated] = await tx
            .update(keyAssignmentTable)
            .set({ lostAt: now })
            .where(eq(keyAssignmentTable.id, assignmentId))
            .returning();
        await tx.update(keyItemsTable).set({ status: 'lost' }).where(eq(keyItemsTable.id, a.keyItemId));
        return updated;
    });
};

export const reactivateFoundKeyItem = async (keyItemId: string): Promise<KeyItemEntry | undefined> => {
    // clear nothing in assignments (history remains), just set item back to active if not assigned
    const active = await db
        .select({ id: keyAssignmentTable.id })
        .from(keyAssignmentTable)
        .where(and(eq(keyAssignmentTable.keyItemId, keyItemId), isNull(keyAssignmentTable.returnedAt), isNull(keyAssignmentTable.lostAt)))
        .limit(1);
    if (active.length > 0) {
        throw new Error('Schlüssel ist aktiv zugewiesen.');
    }
    const [row] = await db.update(keyItemsTable).set({ status: 'active' }).where(eq(keyItemsTable.id, keyItemId)).returning();
    return row;
};
